[include mainsail.cfg]

#[include macros.cfg]

#[include adxl345-v2.0.cfg]

[include shell_command.cfg]

[input_shaper]
#shaper_type_x = mzv
#shaper_freq_x = 0
#shaper_type_y = mzv
#shaper_freq_y = 0
damping_ratio_x: 0.1
damping_ratio_y: 0.1

[include KAMP_Settings.cfg]

[include Adaptive_Mesh.cfg]

[include Voron_Purge.cfg]

[exclude_object]

[virtual_sdcard]
path: /home/ender5/printer_data/gcodes

on_error_gcode: CANCEL_PRINT

[virtual_sdcard][virtual_sdcard]
path: /home/ender5/printer_data/gcodes
on_error_gcode: CANCEL_PRINT

# This file contains common pin mappings for the BIGTREETECH SKR mini
# E3 v3.0. To use this config, the firmware should be compiled for the
# STM32G0B1 with a "8KiB bootloader" and USB communication.

# The "make flash" command does not work on the SKR mini E3. Instead,
# after running "make", copy the generated "out/klipper.bin" file to a
# file named "firmware.bin" on an SD card and then restart the SKR
# mini E3 with that SD card.

# See docs/Config_Reference.md for a description of parameters.

[temperature_sensor raspberry_pi]
sensor_type: temperature_host
max_temp: 100

[temperature_sensor mcu_temp]
sensor_type: temperature_mcu
min_temp: 0
max_temp: 100

[bltouch]
sensor_pin: ^PC14
control_pin: PA1
x_offset: -43
y_offset: -6
samples: 2
speed: 2
#z_offset: 0.0

[bed_mesh]
speed: 80
horizontal_move_z: 6
mesh_min: 37, 22       #!!min and max co-ords are based on the probes location not the nozzle!!
mesh_max: 322, 340  #needs to be calibrated for your individual printer
probe_count: 5,5 #this is the number of probing points on X then Y axis
mesh_pps: 2,2
fade_start: 1
fade_end: 10
fade_target: 0

[safe_z_home]
home_xy_position: 182.5,182.5
speed: 50
z_hop: 10
z_hop_speed: 5

[stepper_x]
step_pin: PB13
dir_pin: !PB12
enable_pin: !PB14
microsteps: 16
rotation_distance: 40
endstop_pin: ^PC0
position_endstop: 365
position_max: 366
Position_min: 20
homing_speed: 50

[tmc2209 stepper_x]
uart_pin: PC11
tx_pin: PC10
uart_address: 0
run_current: 0.580
stealthchop_threshold: 999999

[stepper_y]
step_pin: PB10
dir_pin: !PB2
enable_pin: !PB11
microsteps: 16
rotation_distance: 40
endstop_pin: ^PC1
position_endstop: 365
position_max: 365
Position_min: 15
homing_speed: 50

[tmc2209 stepper_y]
uart_pin: PC11
tx_pin: PC10
uart_address: 2
run_current: 0.580
stealthchop_threshold: 999999

[stepper_z]
step_pin: PB0
dir_pin: !PC5
enable_pin: !PB1
microsteps: 16
rotation_distance: 4
endstop_pin: probe: z_virtual_endstop
#position_endstop: 0.0
position_max: 400
position_min: -10.2

[tmc2209 stepper_z]
uart_pin: PC11
tx_pin: PC10
uart_address: 1
run_current: 0.580
stealthchop_threshold: 999999

[extruder]
step_pin: PB3
dir_pin: !PB4
enable_pin: !PD1
microsteps: 16
rotation_distance: 22.886
nozzle_diameter: 0.400
max_extrude_cross_section: 5
filament_diameter: 1.750
heater_pin: PC8
sensor_type: EPCOS 100K B57560G104F
sensor_pin: PA0
#control: pid
#pid_Kp: 21.527
#pid_Ki: 1.063
#pid_Kd: 108.982
min_temp: -5
max_temp: 300

[tmc2209 extruder]
uart_pin: PC11
tx_pin: PC10
uart_address: 3
run_current: 0.650
stealthchop_threshold: 999999

[heater_bed]
heater_pin: PC9
sensor_type: ATC Semitec 104GT-2
sensor_pin: PC4
#control: pid
#pid_Kp: 54.027
#pid_Ki: 0.770
#pid_Kd: 948.182
min_temp: -5
max_temp: 130

[heater_fan heatbreak_cooling_fan]
pin: PC7

[heater_fan controller_fan]
pin: PB15

[fan]
pin: PC6

[pause_resume]

#[display]
#spi_software_mosi_pin: PD6
#spi_software_sclk_pin: PB9
#en_pin: PB8
#encoder_pins: ^PA10, ^PA9
#click_pin: ^!PA15


[mcu]
serial: /dev/serial/by-id/usb-Klipper_stm32g0b1xx_480035000B504B5735313920-if00
#/dev/ttyAMA0
#/dev/serial/by-id/usb-Klipper_stm32g0b1xx_480035000B504B5735313920-if00

[printer]
kinematics: cartesian
max_velocity: 300
max_accel: 3000
max_z_velocity: 5
max_z_accel: 100

[screws_tilt_adjust]
screw1: 74, 56
screw1_name: front left screw
screw2: 365, 56
screw2_name: front right screw
screw3: 365, 320
screw3_name: rear right screw
screw4: 74, 320
screw4_name: rear left screw
horizontal_move_z: 10.
speed: 50.
screw_thread: CW-M3

[firmware_retraction]
retract_length: .3
#   The length of filament (in mm) to retract when G10 is activated,
#   and to unretract when G11 is activated (but see
#   unretract_extra_length below). The default is 0 mm.
retract_speed: 35
#   The speed of retraction, in mm/s. The default is 20 mm/s.
unretract_extra_length: 0
#   The length (in mm) of *additional* filament to add when
#   unretracting.
unretract_speed: 10
#   The speed of unretraction, in mm/s. The default is 10 mm/s.



[board_pins]
aliases:
    # EXP1 header
    EXP1_1=PB5,  EXP1_3=PA9,   EXP1_5=PA10, EXP1_7=PB8, EXP1_9=<GND>,
    EXP1_2=PA15, EXP1_4=<RST>, EXP1_6=PB9,  EXP1_8=PD6, EXP1_10=<5V>

# See the sample-lcd.cfg file for definitions of common LCD displays.

[gcode_macro home_check]
description: Checks if the printer is homed, it not it homes the printer
gcode:
  {% if printer.toolhead.homed_axes != "xyz" %}
  G28
  {% endif %}

[gcode_macro PID_EXTRUDER]
description: PID Tune for the Extruder
gcode:
  {% set TARGET_TEMP = params.TARGET_TEMP|default(200)|float %} 
  PID_CALIBRATE HEATER=extruder TARGET={TARGET_TEMP}
  TURN_OFF_HEATERS
  SAVE_CONFIG

[gcode_macro PID_BED]
description: PID Tune for the Bed
gcode:
  {% set TARGET_TEMP = params.TARGET_TEMP|default(60)|float %} 
  PID_CALIBRATE HEATER=heater_bed TARGET={TARGET_TEMP}
  TURN_OFF_HEATERS
  SAVE_CONFIG

[gcode_macro SHOW_PRINT]
description: Moves the extruder out of the way and bed forward
gcode:
    HOME_CHECK
    {% set Z = params.Z|default(50)|int %}
    {% set axis_max = printer.toolhead.axis_maximum %}
    {% set pos = printer.toolhead.position %}
 
    {% set z_diff = axis_max.z - pos.z %}
    {% set z_safe_lift = [ Z, z_diff ] | min%}
    G1 Z{ z_safe_lift }
    G1 X10 Y220 F4000

[gcode_macro PREHEAT_PLA]
description: Preheats extruder and bed for PLA printing, extruder set to 150 to prevent filament leaking while homing etc
gcode:
  {% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(150)|float %}
  {% set BED_TEMP = params.BED_TEMP|default(60)|float %}
  SET_HEATER_TEMPERATURE HEATER=extruder TARGET={EXTRUDER_TEMP}
  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={BED_TEMP}  

[gcode_macro PURGE]
description: Extrudes filament, used to clean out previous filament
gcode:
  {% if printer.extruder.temperature < 180 %}
    {action_respond_info("Extruder temperature too low")}
  {% else %}
  {% set PURGE_AMOUNT = params.PURGE_AMOUNT|default(40)|float %}
    SAVE_GCODE_STATE NAME=PURGE_state
    G91                   # relative coords
    G1 E{PURGE_AMOUNT} F{ 5 * 60 }  # purge
    RESTORE_GCODE_STATE NAME=PURGE_state
  {% endif %}  

[gcode_macro CANCEL_PRINT]
description: Cancel the actual running print
rename_existing: CANCEL_PRINT_BASE
gcode:
  ##### get user parameters or use default #####
  {% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
  {% set allow_park = client.park_at_cancel|default(false)|lower == 'true' %}
  {% set retract = client.cancel_retract|default(5.0)|abs %}
  ##### define park position #####
  {% set park_x = "" if (client.park_at_cancel_x|default(none) is none)
            else "X=" ~ client.park_at_cancel_x %}
  {% set park_y = "" if (client.park_at_cancel_y|default(none) is none)
            else "Y=" ~ client.park_at_cancel_y %}
  {% set custom_park = park_x|length > 0 or park_y|length > 0 %}
  ##### end of definitions #####
  # restore idle_timeout time if needed
  {% if printer['gcode_macro RESUME'].restore_idle_timeout > 0 %}
    SET_IDLE_TIMEOUT TIMEOUT={printer['gcode_macro RESUME'].restore_idle_timeout}
  {% endif %}
  {% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}
  _CLIENT_RETRACT LENGTH={retract}
  TURN_OFF_HEATERS
  M106 S0
  {client.user_cancel_macro|default("")}
  SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False
  # clear pause_next_layer and pause_at_layer as preparation for next print
  SET_PAUSE_NEXT_LAYER ENABLE=0
  SET_PAUSE_AT_LAYER ENABLE=0 LAYER=0
  CANCEL_PRINT_BASE

#Enable object exclusion
[exclude_object]

#Use the bed mesh 
 #[BED_MESH]
  #BED_MESH_PROFILE LOAD=default

#Enable arcs support
[gcode_arcs]
 resolution: 0.1

 # # # Klipper Adaptive Meshing # # #

# Heads up! If you have any other BED_MESH_CALIBRATE macros defined elsewhere in your config, you will need to comment out / remove them for this to work. (Klicky/Euclid Probe)
# You will also need to be sure that [exclude_object] is defined in printer.cfg, and your slicer is labeling objects.
# This macro will parse information from objects in your gcode to define a min and max mesh area to probe, creating an adaptive mesh!
# This macro will not increase probe_count values in your [bed_mesh] config. If you want richer meshes, be sure to increase probe_count. We recommend at least 5,5.

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: _BED_MESH_CALIBRATE
gcode:

    {% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}                                # Gather all object points
    {% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}                                                          # Get bed mesh min from printer.cfg
    {% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}                                                          # Get bed mesh max from printer.cfg
    {% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}                                                        # Get probe count from printer.cfg
    {% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}                                                                 # Pull variables from _KAMP_Settings
    {% set verbose_enable = kamp_settings.verbose_enable | abs %}                                                                   # Pull verbose setting from _KAMP_Settings
    {% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}                                                             # Pull probe dockable probe settings from _KAMP_Settings
    {% set attach_macro = kamp_settings.attach_macro | string %}                                                                    # Pull attach probe command from _KAMP_Settings
    {% set detach_macro = kamp_settings.detach_macro | string %}                                                                    # Pull detach probe command from _KAMP_Settings
    {% set mesh_margin = kamp_settings.mesh_margin | float %}                                                                       # Pull mesh margin setting from _KAMP_Settings
    {% set fuzz_amount = kamp_settings.fuzz_amount | float %}                                                                       # Pull fuzz amount setting from _KAMP_Settings
    {% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}                                             # If probe count is only a single number, convert it to 2. E.g. probe_count:7 = 7,7
    {% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}                            # Determine max probe point distance
    {% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}                            # Determine max probe point distance
    {% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}                                                # Set x_min from smallest object x point
    {% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}                                                # Set y_min from smallest object y point
    {% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}                                                # Set x_max from largest object x point
    {% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}                                                # Set y_max from largest object y point

    {% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}                                                          # Set fuzz_range between 0 and fuzz_amount
    {% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}                                                   # Adapt x_min to margin and fuzz constraints
    {% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}                                                   # Adapt y_min to margin and fuzz constraints
    {% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}                                                   # Adapt x_max to margin and fuzz constraints
    {% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}                                                   # Adapt y_max to margin and fuzz constraints

    {% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}                                                               # Compare adjustments to defaults and choose max
    {% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}                                                               # Compare adjustments to defaults and choose max
    {% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}                                                               # Compare adjustments to defaults and choose min
    {% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}                                                               # Compare adjustments to defaults and choose min

    {% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method='ceil') | int) + 1 %}          # Define probe_count's x point count and round up
    {% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method='ceil') | int) + 1 %}          # Define probe_count's y point count and round up

    {% if (([points_x, points_y]|max) > 6) %}                                                                                       # 
        {% set algorithm = "bicubic" %}                                                                                             # 
        {% set min_points = 4 %}                                                                                                    # 
    {% else %}                                                                                                                      # Calculate if algorithm should be bicubic or lagrange
        {% set algorithm = "lagrange" %}                                                                                            # 
        {% set min_points = 3 %}                                                                                                    # 
    {% endif %}                                                                                                                     # 

    {% set points_x = [points_x , min_points]|max %}                                                                                # Set probe_count's x points to fit the calculated algorithm
    {% set points_y = [points_y , min_points]|max %}                                                                                # Set probe_count's y points to fit the calculated algorithm
    {% set points_x = [points_x , probe_count[0]]|min %}
    {% set points_y = [points_y , probe_count[1]]|min %}

    {% if verbose_enable == True %}                                                                                                 # If verbose is enabled, print information about KAMP's calculations
        {% if printer.exclude_object.objects != [] %}

            { action_respond_info( "Algorithm: {}.".format(                                                                              
                (algorithm),                                                                                                            
            )) }

            { action_respond_info("Default probe count: {},{}.".format(                                                                  
                (probe_count[0]),                                                                                                       
                (probe_count[1]),                                                                                                       
            )) }

            { action_respond_info("Adapted probe count: {},{}.".format(                                                                  
                (points_x),                                                                                                             
                (points_y),                                                                                                             
            )) }                                                                                                              

            {action_respond_info("Default mesh bounds: {}, {}.".format(                                                                  
                (bed_mesh_min[0],bed_mesh_min[1]),                                                                                      
                (bed_mesh_max[0],bed_mesh_max[1]),                                                                                      
            )) }

            {% if mesh_margin > 0 %}                                                                                                    
                {action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(                                       
                    (mesh_margin),                                                                                                      
                    (mesh_margin),                                                                                       
                )) }                                                                                                                    
            {% else %}                                                                                                                  
                {action_respond_info("Mesh margin is 0, margin not increased.")}                                                        
            {% endif %}                                                                                                                 

            {% if fuzz_amount > 0 %}                                                                                                    
                {action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(                                     
                    (fuzz_amount),                                                                                                      
                )) }                                                                                                                    
            {% else %}                                                                                                                  
                {action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}                                                      
            {% endif %}                                                                                                                 

            { action_respond_info("Adapted mesh bounds: {}, {}.".format(                                                                 
                (adapted_x_min, adapted_y_min),                                                                                         
                (adapted_x_max, adapted_y_max),                                                                                         
            )) }

            {action_respond_info("KAMP adjustments successful. Happy KAMPing!")}

        {% else %}

            {action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}
            G4 P5000                                                                                                                # Wait 5 seconds to make error more visible
        {% endif %}

    {% endif %}

    {% if probe_dock_enable == True %}
        {attach_macro}                                                                                                              # Attach/deploy a probe if the probe is stored somewhere outside of the print area
    {% endif %}

    _BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}

    {% if probe_dock_enable == True %}
        {detach_macro}                                                                                                              # Detach/stow a probe if the probe is stored somewhere outside of the print area
    {% endif %}                                                                                                                     # End of verbose

[gcode_macro PAUSE]
description: Pause the actual running print
rename_existing: PAUSE_BASE
gcode:
  ##### get user parameters or use default ##### 
  {% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
  {% set idle_timeout = client.idle_timeout|default(0) %}
  {% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != '' else 0 %}
  {% set restore = False if printer.toolhead.extruder == ''
              else True  if params.RESTORE|default(1)|int == 1 else False %}
  ##### end of definitions #####
  SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{'restore': restore, 'temp': temp}}"
  # set a new idle_timeout value
  {% if idle_timeout > 0 %}
    SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}
    SET_IDLE_TIMEOUT TIMEOUT={idle_timeout}
  {% endif %}
  PAUSE_BASE
  {client.user_pause_macro|default("")}
  _TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}

[gcode_macro RESUME]
description: Resume the actual running print
rename_existing: RESUME_BASE
variable_last_extruder_temp: {'restore': False, 'temp': 0}
variable_restore_idle_timeout: 0
variable_idle_state: False
gcode:
  ##### get user parameters or use default #####
  {% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
  {% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
  {% set sp_move = client.speed_move|default(velocity) %}
  {% set runout_resume = True if client.runout_sensor|default("") == ""     # no runout
                    else True if not printer[client.runout_sensor].enabled  # sensor is disabled
                    else printer[client.runout_sensor].filament_detected %} # sensor status
  {% set can_extrude = True if printer.toolhead.extruder == ''           # no extruder defined in config
                  else printer[printer.toolhead.extruder].can_extrude %} # status of active extruder
  {% set do_resume = False %}
  ##### end of definitions #####
  #### Printer comming from timeout idle state ####
  {% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}
    SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False
    {% if last_extruder_temp.restore %}
      # we need to use the unicode (\u00B0) for the Â° as py2 env's would throw an error otherwise 
      RESPOND TYPE=echo MSG='{"Restoring \"%s\" temperature to %3.1f\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }'
      M109 S{last_extruder_temp.temp}
      {% set do_resume = True %}
    {% elif can_extrude %}
      {% set do_resume = True %}
    {% else %} 
      RESPOND TYPE=error MSG='{"Resume aborted !!! \"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}'
    {% endif %}
  #### Printer comming out of regular PAUSE state ####
  {% elif can_extrude %}
    {% set do_resume = True %}
  {% else %}
    RESPOND TYPE=error MSG='{"Resume aborted !!! \"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}'
  {% endif %}
  {% if runout_resume %}
    {% if do_resume %}
      {% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %} # restore idle_timeout time
      {client.user_resume_macro|default("")}
      _CLIENT_EXTRUDE
      RESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}
    {% endif %}
  {% else %}
    RESPOND TYPE=error MSG='{"Resume aborted !!! \"%s\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}'
  {% endif %}
  
# Usage: SET_PAUSE_NEXT_LAYER [ENABLE=[0|1]] [MACRO=<name>]
[gcode_macro SET_PAUSE_NEXT_LAYER]
description: Enable a pause if the next layer is reached
gcode:
  {% set pause_next_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer %}
  {% set ENABLE = params.ENABLE|default(1)|int != 0 %}
  {% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}
  SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ 'enable': ENABLE, 'call': MACRO }}"

# Usage: SET_PAUSE_AT_LAYER [ENABLE=[0|1]] [LAYER=<number>] [MACRO=<name>]
[gcode_macro SET_PAUSE_AT_LAYER]
description: Enable/disable a pause if a given layer number is reached
gcode:
  {% set pause_at_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer %}
  {% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined
             else params.LAYER is defined %}
  {% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}
  {% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}
  SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ 'enable': ENABLE, 'layer': LAYER, 'call': MACRO }}"

# Usage: SET_PRINT_STATS_INFO [TOTAL_LAYER=<total_layer_count>] [CURRENT_LAYER= <current_layer>]
[gcode_macro SET_PRINT_STATS_INFO]
rename_existing: SET_PRINT_STATS_INFO_BASE
description: Overwrite, to get pause_next_layer and pause_at_layer feature
variable_pause_next_layer: { 'enable': False, 'call': "PAUSE" }
variable_pause_at_layer  : { 'enable': False, 'layer': 0, 'call': "PAUSE" }
gcode:
  {% if pause_next_layer.enable %}
    RESPOND TYPE=echo MSG='{"%s, forced by pause_next_layer" % pause_next_layer.call}'
    {pause_next_layer.call} ; execute the given gcode to pause, should be either M600 or PAUSE
    SET_PAUSE_NEXT_LAYER ENABLE=0
  {% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}
    RESPOND TYPE=echo MSG='{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}'
    {pause_at_layer.call} ; execute the given gcode to pause, should be either M600 or PAUSE
    SET_PAUSE_AT_LAYER ENABLE=0
  {% endif %}
  SET_PRINT_STATS_INFO_BASE {rawparams}
  
##### internal use #####
[gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL]
description: Helper: park toolhead used in PAUSE and CANCEL_PRINT
gcode:
  ##### get user parameters or use default #####
  {% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
  {% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
  {% set use_custom     = client.use_custom_pos|default(false)|lower == 'true' %}
  {% set custom_park_x  = client.custom_park_x|default(0.0) %}
  {% set custom_park_y  = client.custom_park_y|default(0.0) %}
  {% set park_dz        = client.custom_park_dz|default(2.0)|abs %}
  {% set sp_hop         = client.speed_hop|default(15) * 60 %}
  {% set sp_move        = client.speed_move|default(velocity) * 60 %}
  ##### get config and toolhead values #####
  {% set origin    = printer.gcode_move.homing_origin %}
  {% set act       = printer.gcode_move.gcode_position %}
  {% set max       = printer.toolhead.axis_maximum %}
  {% set cone      = printer.toolhead.cone_start_z|default(max.z) %} ; height as long the toolhead can reach max and min of an delta
  {% set round_bed = True if printer.configfile.settings.printer.kinematics is in ['delta','polar','rotary_delta','winch']
                else False %}
  ##### define park position #####
  {% set z_min = params.Z_MIN|default(0)|float %}
  {% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}
  {% set x_park = params.X       if params.X is defined
             else custom_park_x  if use_custom
             else 0.0            if round_bed
             else (max.x - 5.0) %}
  {% set y_park = params.Y       if params.Y is defined
             else custom_park_y  if use_custom
             else (max.y - 5.0)  if round_bed and z_park < cone
             else 0.0            if round_bed
             else (max.y - 5.0) %}
  ##### end of definitions #####
  _CLIENT_RETRACT
  {% if "xyz" in printer.toolhead.homed_axes %}
    G90
    G1 Z{z_park} F{sp_hop}
    G1 X{x_park} Y{y_park} F{sp_move}
    {% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}
  {% else %}
    RESPOND TYPE=echo MSG='Printer not homed'
  {% endif %}
  
[gcode_macro _CLIENT_EXTRUDE]
description: Extrudes, if the extruder is hot enough
gcode:
  ##### get user parameters or use default #####
  {% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
  {% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}
  {% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}
  {% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}
  {% set absolute_extrude = printer.gcode_move.absolute_extrude %}
  ##### end of definitions #####
  {% if printer.toolhead.extruder != '' %}
    {% if printer[printer.toolhead.extruder].can_extrude %}
      {% if use_fw_retract %}
        {% if length < 0 %}
          G10
        {% else %}
          G11
        {% endif %}
      {% else %}
        M83
        G1 E{length} F{(speed|float|abs) * 60}
        {% if absolute_extrude %}
          M82
        {% endif %}
      {% endif %}
    {% else %}
      RESPOND TYPE=echo MSG='{"\"%s\" not hot enough" % printer.toolhead.extruder}'
    {% endif %}
  {% endif %}

#[gcode_macro PRINT_END]
gcode:
    {% set intro_x = printer.configfile.config["stepper_x"]["position_max"]|float * 0.66 %}
    {% set min_x = printer.configfile.config["stepper_x"]["position_min"]|float * 0.1 %}
    {% set min_y = printer.configfile.config["stepper_y"]["position_min"]|float %}
    G1 X{min_x} Y{min_y} F5000 ; move to min
    TURN_OFF_HEATERS
    M107 ; disable fans
    M84 X Y E ; disable motors x,y,e
    
[gcode_macro END_PRINT]
gcode:
    M117 Done printing :)
    # move z up
    G91
    G1 E-3 Z10 F3000
    # absolute xy 
    G90
    G1 X10 Y220 F2000
    #disable hotend and heated bed
    M104 S0
    M140 S0
    # disable steppers
    
#[gcode_macro END_PRINT]
gcode:
    Turn off bed, extruder, and fan
    M140 S0
    M104 S0
    M106 S0
     Move nozzle away from print while retracting
    G91
    G1 X-2 Y-2 E-3 F300
     Raise nozzle by 10mm
    G1 Z10 F3000
    G90
     Disable steppers except Z
    M84 X Y E
    DGUS_PRINT_END

[gcode_macro _CLIENT_RETRACT]
description: Retracts, if the extruder is hot enough
gcode:
  {% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
  {% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}
  {% set speed = params.SPEED|default(client.speed_retract)|default(35) %}

  _CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}

[include moonraker_obico_macros.cfg]
#*# <---------------------- SAVE_CONFIG ---------------------->
#*# DO NOT EDIT THIS BLOCK OR BELOW. The contents are auto-generated.
#*#
#*# [bltouch]
#*# z_offset = 2.870
#*#
#*# [bed_mesh default]
#*# version = 1
#*# points =
#*# 	-0.198125, -0.172500, -0.153125, -0.172500, -0.193125
#*# 	-0.101250, -0.046875, -0.004375, -0.006875, -0.038750
#*# 	-0.050625, 0.005625, 0.040000, 0.021875, -0.012500
#*# 	-0.108750, -0.066250, -0.048125, -0.051250, -0.081250
#*# 	-0.210625, -0.224375, -0.231250, -0.193750, -0.175000
#*# x_count = 5
#*# y_count = 5
#*# mesh_x_pps = 2
#*# mesh_y_pps = 2
#*# algo = lagrange
#*# tension = 0.2
#*# min_x = 37.0
#*# max_x = 322.0
#*# min_y = 22.0
#*# max_y = 340.0
#*#
#*# [input_shaper]
#*# shaper_type_x = mzv
#*# shaper_freq_x = 63.0
#*# shaper_type_y = mzv
#*# shaper_freq_y = 43.2
#*#
#*# [extruder]
#*# control = pid
#*# pid_kp = 25.311
#*# pid_ki = 1.329
#*# pid_kd = 120.542
#*#
#*# [heater_bed]
#*# control = pid
#*# pid_kp = 69.892
#*# pid_ki = 0.900
#*# pid_kd = 1357.648
